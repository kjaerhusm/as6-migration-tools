name: Cleanup Old CalVer Releases

permissions:
  contents: write   # needed to delete releases and tags

on:
  schedule:
    # Runs daily at 01:10 UTC (Actions uses UTC; this is nighttime in DK year-round)
    - cron: '10 1 * * *'
  workflow_dispatch:
    # Manual runs with parameters; default is DRY-RUN so you can preview first
    inputs:
      dry_run:
        description: "Don't delete; only show what WOULD be deleted"
        type: boolean
        default: true
      retention_days:
        description: "Rolling window in days"
        type: number
        default: 28
      max_keep:
        description: "Max CalVer releases to KEEP within the window (Intersection policy)"
        type: number
        default: 5
      # keep_latest:
      #   description: "Always keep the repository's 'Latest' release (GitHub's latest)"
      #   type: boolean
      #   default: true

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      # --- Added: snapshot lifetime downloads BEFORE any deletions ---
      - name: Checkout (for badge update)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update lifetime downloads badge (pre-cleanup)
        env:
          REPO_FULL: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python - << 'PY'
          import json, os, urllib.request, datetime, pathlib

          repo = os.environ["REPO_FULL"]
          token = os.environ["GITHUB_TOKEN"]

          history_path = pathlib.Path("downloads/history.json")
          badge_path = pathlib.Path("badges/lifetime-downloads.json")
          history_path.parent.mkdir(parents=True, exist_ok=True)
          badge_path.parent.mkdir(parents=True, exist_ok=True)

          def gh(url: str):
            req = urllib.request.Request(url, headers={
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "as6-migration-tools-badges"
            })
            with urllib.request.urlopen(req, timeout=30) as r:
              return json.loads(r.read().decode())

          history = {"assets": {}, "last_updated": None}
          if history_path.exists():
            try:
              history = json.loads(history_path.read_text(encoding="utf-8"))
            except Exception:
              pass
          assets = history.get("assets", {})

          page = 1
          while True:
            releases = gh(f"https://api.github.com/repos/{repo}/releases?per_page=100&page={page}")
            if not releases:
              break
            for rel in releases:
              tag = rel.get("tag_name") or ""
              for a in rel.get("assets", []):
                aid = str(a["id"])
                current = int(a.get("download_count") or 0)
                entry = assets.get(aid, {"name": a.get("name"), "release_tag": tag, "max_downloads": 0})
                if current > int(entry.get("max_downloads", 0)):
                  entry["max_downloads"] = current
                entry["name"] = a.get("name")
                entry["release_tag"] = tag
                assets[aid] = entry
            page += 1

          history["assets"] = assets
          history["last_updated"] = datetime.datetime.utcnow().isoformat(timespec="seconds") + "Z"
          history_path.write_text(json.dumps(history, indent=2, ensure_ascii=False), encoding="utf-8")

          lifetime_total = sum(int(v.get("max_downloads", 0)) for v in assets.values())
          badge = {
            "schemaVersion": 1,
            "label": "downloads",
            "message": f"{lifetime_total:,} total",
            "color": "blue"
          }
          badge_path.write_text(json.dumps(badge, indent=2), encoding="utf-8")
          PY

      - name: Commit badge updates (pre-cleanup)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add downloads/history.json badges/lifetime-downloads.json 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "No badge changes (pre-cleanup)."
          else
            git commit -m "Update lifetime downloads badge before cleanup"
            git push
          fi

      # --- Existing cleanup step unchanged ---
      - name: Prune CalVer releases (keep top N within last X days)
        uses: actions/github-script@v7
        with:
          script: |
            /**
             * Intersection policy:
             *  - Collect all CalVer releases (tags like vYYYY.MM.DD.HHMM).
             *  - Partition into: within last RETENTION_DAYS vs. older than that.
             *  - Within the window, KEEP only the newest MAX_KEEP; delete the rest.
             *  - Outside the window, delete all.
             * Guardrails:
             *  - Optionally ALWAYS keep GitHub's "Latest" release (even if older than window).
             *  - Only touch CalVer-matching tags; ignore everything else (e.g., SemVer).
             *
             * Notes:
             *  - parseInt(..., 10) enforces base-10 (decimal) parsing.
             *  - per_page: 100 is the REST API max per page (fewer requests).
             *  - max_keep = 1 means: within the 28-day window, keep ONLY the newest.
             */

            const { owner, repo } = context.repo;          // 'context' is provided by github-script
            const DRY = (core.getInput('dry_run') || 'false') === 'true';
            const RETENTION_DAYS = Math.max(1, parseInt(core.getInput('retention_days') || '28', 10));
            const MAX_KEEP = Math.max(1, parseInt(core.getInput('max_keep') || '5', 10));
            const KEEP_LATEST = (core.getInput('keep_latest') || 'true') === 'true';

            const CALVER = /^v\d{4}\.\d{2}\.\d{2}\.\d{4}$/;
            const now = new Date();
            const cutoff = new Date(now.getTime() - RETENTION_DAYS * 24 * 60 * 60 * 1000);

            // Fetch all releases (paginated)
            const all = [];
            for (let page = 1; ; page++) {
              const { data } = await github.rest.repos.listReleases({ owner, repo, per_page: 100, page });
              if (!data.length) break;
              all.push(...data);
            }

            // Identify GitHub's "Latest" release
            let latestId = null;
            try {
              const { data: latest } = await github.rest.repos.getLatestRelease({ owner, repo });
              latestId = latest.id;
            } catch (e) {
              // no latest yet
            }

            const relTime = (r) => new Date(r.published_at || r.created_at || 0);

            const calver = all
              .filter(r => r.tag_name && CALVER.test(r.tag_name) && !r.draft)
              .sort((a, b) => relTime(b) - relTime(a));

            const inWindow = [];
            const outWindow = [];
            for (const r of calver) (relTime(r) >= cutoff ? inWindow : outWindow).push(r);

            const keep = new Set(inWindow.slice(0, MAX_KEEP).map(r => r.id));
            if (KEEP_LATEST && latestId) keep.add(latestId);

            const toDelete = [];
            for (let i = MAX_KEEP; i < inWindow.length; i++) if (!keep.has(inWindow[i].id)) toDelete.push(inWindow[i]);
            for (const r of outWindow) if (!keep.has(r.id)) toDelete.push(r);

            const lines = [];
            lines.push(`Policy: KEEP top ${MAX_KEEP} within last ${RETENTION_DAYS} days (intersection)`);
            lines.push(`Cutoff (UTC): ${cutoff.toISOString()}`);
            lines.push(`Total releases: ${all.length}`);
            lines.push(`CalVer releases: ${calver.length}`);
            lines.push(`In-window: ${inWindow.length}, Out-of-window: ${outWindow.length}`);
            lines.push(`Keeping in-window: ${Math.min(inWindow.length, MAX_KEEP)}`);
            lines.push(`Keeping 'Latest': ${KEEP_LATEST && latestId ? 'yes' : 'no'}`);
            lines.push(`To delete: ${toDelete.length} ${DRY ? '(DRY-RUN)' : ''}`);
            lines.push('');
            for (const r of toDelete) lines.push(`- ${r.tag_name} | created ${r.created_at} | url: ${r.html_url}`);
            core.summary.addHeading('CalVer Cleanup Summary');
            core.summary.addRaw(lines.join('\n') + '\n');
            await core.summary.write();

            if (!DRY) {
              for (const r of toDelete) {
                try { await github.rest.repos.deleteRelease({ owner, repo, release_id: r.id }); core.info(`Deleted release ${r.tag_name}`); }
                catch (e) { core.warning(`Failed to delete release ${r.tag_name}: ${e.message}`); }
                try { await github.rest.git.deleteRef({ owner, repo, ref: `tags/${r.tag_name}` }); core.info(`Deleted tag ${r.tag_name}`); }
                catch (e) { core.warning(`Failed to delete tag ${r.tag_name}: ${e.message}`); }
              }
            } else {
              core.info('DRY-RUN: no deletions performed.');
            }
